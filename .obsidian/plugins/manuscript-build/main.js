/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ManuscriptBuildPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  pythonPath: "python3",
  buildScriptPath: "build.py",
  defaultProfile: "pdf-default",
  defaultFont: "",
  defaultFontSize: "11pt",
  defaultCitationStyle: "vancouver",
  showNotifications: true,
  autoOpenExport: false
};
var FONT_PRESETS = {
  libertinus: "Libertinus (Default)",
  "libertinus-serif": "Libertinus Serif",
  "libertinus-sans": "Libertinus Sans",
  inter: "Inter",
  "ibm-plex-sans": "IBM Plex Sans",
  "ibm-plex-serif": "IBM Plex Serif",
  switzer: "Switzer",
  times: "Times/TeX Gyre Termes",
  palatino: "Palatino/TeX Gyre Pagella",
  arial: "Arial",
  helvetica: "Helvetica-like (TeX Gyre Heros)",
  charter: "Charter",
  "computer-modern": "Computer Modern (LaTeX default)"
};
var FONT_SIZES = ["9pt", "10pt", "11pt", "12pt"];
var LINE_SPACING_PRESETS = {
  "": "Profile Default",
  single: "Single (1.0)",
  compact: "Compact (1.15)",
  normal: "Normal (1.25)",
  relaxed: "Relaxed (1.5)",
  double: "Double (2.0)"
};
var PARAGRAPH_STYLE_PRESETS = {
  "": "Profile Default",
  indent: "Indented (American)",
  gap: "Gap (European)",
  both: "Gap + Indent (Both)"
};
var LANGUAGE_PRESETS = {
  "": "Default (English)",
  en: "English",
  de: "German (Deutsch)",
  fr: "French (Fran\xE7ais)",
  es: "Spanish (Espa\xF1ol)",
  it: "Italian (Italiano)",
  pt: "Portuguese (Portugu\xEAs)",
  nl: "Dutch (Nederlands)",
  pl: "Polish (Polski)",
  ru: "Russian (\u0420\u0443\u0441\u0441\u043A\u0438\u0439)",
  zh: "Chinese (\u4E2D\u6587)",
  ja: "Japanese (\u65E5\u672C\u8A9E)"
};
var CITATION_STYLE_NAMES = {
  vancouver: "Vancouver",
  nature: "Nature",
  cell: "Cell",
  science: "Science",
  pnas: "PNAS",
  plos: "PLOS",
  apa: "APA 7th Edition",
  "apa-7th-edition": "APA 7th Edition",
  chicago: "Chicago Author-Date",
  "chicago-author-date": "Chicago Author-Date",
  "acs-synthetic-biology": "ACS Synthetic Biology",
  "angewandte-chemie": "Angewandte Chemie",
  "nucleic-acids-research": "Nucleic Acids Research"
};
var FALLBACK_PROFILES = [
  { id: "docx-manuscript", name: "Word Manuscript", format: "docx", category: "General" },
  { id: "pdf-default", name: "PDF Default", format: "pdf", category: "General" }
];
var ManuscriptBuildPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.buildProcess = null;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("file-output", "Build Manuscript", async () => {
      const lastConfig = await this.loadLastBuildConfig();
      new BuildModal(this.app, this, lastConfig).open();
    });
    this.addCommand({
      id: "open-build-modal",
      name: "Open Build Dialog",
      callback: async () => {
        const lastConfig = await this.loadLastBuildConfig();
        new BuildModal(this.app, this, lastConfig).open();
      }
    });
    this.addCommand({
      id: "build-current-file",
      name: "Build Current File",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          this.buildWithDefaults(activeFile.name);
        } else {
          new import_obsidian.Notice("No markdown file is currently active");
        }
      }
    });
    this.addSettingTab(new ManuscriptBuildSettingTab(this.app, this));
  }
  onunload() {
    if (this.buildProcess) {
      this.buildProcess.kill();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    return adapter.basePath || "";
  }
  getMarkdownFiles() {
    const files = this.app.vault.getMarkdownFiles();
    return files.filter((f) => !f.path.includes("/")).map((f) => f.name).filter((name) => !name.startsWith("_") && name.toLowerCase() !== "readme.md").sort();
  }
  getCitationStyles() {
    const styles = {};
    const vaultPath = this.getVaultPath();
    const stylesDir = path.join(vaultPath, "resources", "citation_styles");
    try {
      const fs = require("fs");
      if (fs.existsSync(stylesDir)) {
        const files = fs.readdirSync(stylesDir);
        files.filter((f) => f.endsWith(".csl")).forEach((f) => {
          const id = f.replace(".csl", "");
          const displayName = CITATION_STYLE_NAMES[id] || this.formatStyleName(id);
          styles[id] = displayName;
        });
      }
    } catch (e) {
      console.error("Failed to read citation styles:", e);
    }
    if (Object.keys(styles).length === 0) {
      return { vancouver: "Vancouver", nature: "Nature" };
    }
    const sorted = {};
    Object.entries(styles).sort((a, b) => a[1].localeCompare(b[1])).forEach(([k, v]) => {
      sorted[k] = v;
    });
    return sorted;
  }
  formatStyleName(id) {
    return id.split("-").map((word) => {
      if (word.length <= 3 && word === word.toLowerCase()) {
        return word.toUpperCase();
      }
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join(" ");
  }
  getProfiles() {
    const profiles = [];
    const vaultPath = this.getVaultPath();
    const profilesDir = path.join(vaultPath, "resources", "profiles");
    try {
      const fs = require("fs");
      if (fs.existsSync(profilesDir)) {
        const files = fs.readdirSync(profilesDir);
        files.filter((f) => f.endsWith(".yaml") && !f.startsWith("_")).forEach((f) => {
          const id = f.replace(".yaml", "");
          const filePath = path.join(profilesDir, f);
          try {
            const content = fs.readFileSync(filePath, "utf8");
            const profileInfo = this.parseProfileYaml(id, content);
            if (profileInfo) {
              profiles.push(profileInfo);
            }
          } catch (e) {
            console.error(`Failed to read profile ${f}:`, e);
          }
        });
      }
    } catch (e) {
      console.error("Failed to read profiles directory:", e);
    }
    if (profiles.length === 0) {
      return FALLBACK_PROFILES;
    }
    return profiles.sort((a, b) => {
      var _a, _b;
      const catOrder = { General: 0, Thesis: 1, Journals: 2 };
      const catA = (_a = catOrder[a.category]) != null ? _a : 99;
      const catB = (_b = catOrder[b.category]) != null ? _b : 99;
      if (catA !== catB)
        return catA - catB;
      return a.name.localeCompare(b.name);
    });
  }
  parseProfileYaml(id, content) {
    const nameMatch = content.match(/^\s*name:\s*["']?([^"'\n]+)["']?\s*$/m);
    const formatMatch = content.match(/^\s*format:\s*["']?([^"'\n]+)["']?\s*$/m);
    if (!nameMatch) {
      return {
        id,
        name: this.formatStyleName(id),
        format: id.startsWith("docx") ? "docx" : "pdf",
        category: this.inferCategory(id)
      };
    }
    const name = nameMatch[1].trim();
    const format = formatMatch ? formatMatch[1].trim() : id.startsWith("docx") ? "docx" : "pdf";
    return {
      id,
      name,
      format,
      category: this.inferCategory(id)
    };
  }
  inferCategory(id) {
    if (id.includes("thesis"))
      return "Thesis";
    if (id.includes("nature") || id.includes("cell") || id.includes("journal"))
      return "Journals";
    return "General";
  }
  async buildWithDefaults(sourceFile) {
    const config = {
      sourceFile,
      frontmatterFile: null,
      profile: this.settings.defaultProfile,
      usePng: false,
      includeSiRefs: false,
      siFile: null,
      isSi: false,
      font: this.settings.defaultFont,
      fontSize: this.settings.defaultFontSize,
      citationStyle: this.settings.defaultCitationStyle,
      lineSpacing: "",
      paragraphStyle: "",
      lineNumbers: null,
      numberedHeadings: null,
      language: ""
    };
    this.executeBuild(config);
  }
  async loadLastBuildConfig() {
    try {
      const configPath = path.join(this.getVaultPath(), ".build_config.json");
      const fs = require("fs");
      if (fs.existsSync(configPath)) {
        const content = fs.readFileSync(configPath, "utf8");
        const data = JSON.parse(content);
        return {
          sourceFile: data.source_file || "",
          frontmatterFile: data.frontmatter_file || null,
          profile: data.profile || this.settings.defaultProfile,
          usePng: data.use_png || false,
          includeSiRefs: data.include_si_refs || false,
          siFile: data.si_file || null,
          isSi: data.is_si || false,
          font: data.font !== void 0 ? data.font : this.settings.defaultFont,
          fontSize: data.fontsize || this.settings.defaultFontSize,
          citationStyle: data.citation_style || this.settings.defaultCitationStyle,
          lineSpacing: data.linespacing || "",
          paragraphStyle: data.paragraph_style || "",
          lineNumbers: data.linenumbers !== void 0 ? data.linenumbers : null,
          numberedHeadings: data.numbered_headings !== void 0 ? data.numbered_headings : null,
          language: data.language || ""
        };
      }
    } catch (e) {
      console.error("Failed to load last build config:", e);
    }
    return null;
  }
  executeBuild(config) {
    var _a, _b;
    const vaultPath = this.getVaultPath();
    const args = this.buildCommandArgs(config);
    if (this.settings.showNotifications) {
      new import_obsidian.Notice(`Building ${config.sourceFile}...`);
    }
    const outputModal = new BuildOutputModal(this.app, config.sourceFile);
    outputModal.open();
    this.buildProcess = (0, import_child_process.spawn)(this.settings.pythonPath, args, {
      cwd: vaultPath,
      env: { ...process.env, PAGER: "cat" }
    });
    let stdout = "";
    let stderr = "";
    (_a = this.buildProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
      const text = data.toString();
      stdout += text;
      outputModal.appendOutput(text);
    });
    (_b = this.buildProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
      const text = data.toString();
      stderr += text;
      outputModal.appendOutput(text, true);
    });
    this.buildProcess.on("close", (code) => {
      this.buildProcess = null;
      if (code === 0) {
        outputModal.setSuccess();
        if (this.settings.showNotifications) {
          new import_obsidian.Notice("\u2713 Build complete!");
        }
        if (this.settings.autoOpenExport) {
          this.openExportFolder();
        }
      } else {
        outputModal.setError();
        if (this.settings.showNotifications) {
          new import_obsidian.Notice("\u2717 Build failed. Check output for details.");
        }
      }
    });
    this.buildProcess.on("error", (err) => {
      this.buildProcess = null;
      outputModal.appendOutput(`
Error: ${err.message}`, true);
      outputModal.setError();
      new import_obsidian.Notice(`Build error: ${err.message}`);
    });
  }
  buildCommandArgs(config) {
    const args = [this.settings.buildScriptPath];
    args.push(`--source=${config.sourceFile}`);
    if (config.frontmatterFile) {
      args.push(`--frontmatter=${config.frontmatterFile}`);
    }
    args.push(`--profile=${config.profile}`);
    if (config.usePng) {
      args.push("--png");
    }
    if (config.includeSiRefs) {
      args.push("--include-si-refs");
      if (config.siFile) {
        args.push(`--si-file=${config.siFile}`);
      }
    }
    if (config.isSi) {
      args.push("--si");
    }
    if (config.font) {
      args.push(`--font=${config.font}`);
    }
    if (config.fontSize) {
      args.push(`--fontsize=${config.fontSize}`);
    }
    if (config.lineSpacing) {
      args.push(`--linespacing=${config.lineSpacing}`);
    }
    if (config.paragraphStyle) {
      args.push(`--paragraph-style=${config.paragraphStyle}`);
    }
    if (config.lineNumbers === true) {
      args.push("--linenumbers");
    } else if (config.lineNumbers === false) {
      args.push("--no-linenumbers");
    }
    if (config.numberedHeadings === true) {
      args.push("--numbered-headings");
    } else if (config.numberedHeadings === false) {
      args.push("--no-numbered-headings");
    }
    if (config.language) {
      args.push(`--lang=${config.language}`);
    }
    if (config.citationStyle) {
      args.push(`--csl=${config.citationStyle}`);
    }
    return args;
  }
  openExportFolder() {
    const exportPath = path.join(this.getVaultPath(), "export");
    const { shell } = require("electron");
    shell.openPath(exportPath);
  }
  openCitationStylesFolder() {
    const stylesPath = path.join(this.getVaultPath(), "resources", "citation_styles");
    const fs = require("fs");
    if (!fs.existsSync(stylesPath)) {
      fs.mkdirSync(stylesPath, { recursive: true });
    }
    const { shell } = require("electron");
    shell.openPath(stylesPath);
  }
};
var BuildModal = class extends import_obsidian.Modal {
  constructor(app, plugin, lastConfig = null) {
    super(app);
    this.lastConfig = null;
    this.plugin = plugin;
    this.lastConfig = lastConfig;
    if (lastConfig) {
      this.config = { ...lastConfig };
    } else {
      this.config = {
        sourceFile: "",
        frontmatterFile: null,
        profile: plugin.settings.defaultProfile,
        usePng: false,
        includeSiRefs: false,
        siFile: null,
        isSi: false,
        font: plugin.settings.defaultFont,
        fontSize: plugin.settings.defaultFontSize,
        citationStyle: plugin.settings.defaultCitationStyle,
        lineSpacing: "",
        paragraphStyle: "",
        lineNumbers: null,
        numberedHeadings: null,
        language: ""
      };
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("manuscript-build-modal");
    contentEl.createEl("h2", { text: "Build Manuscript", cls: "modal-title" });
    const mdFiles = this.plugin.getMarkdownFiles();
    this.createSectionHeader(contentEl, "Document");
    new import_obsidian.Setting(contentEl).setName("Source File").setDesc("The main document to build").addDropdown((dropdown) => {
      var _a;
      this.sourceDropdown = dropdown;
      mdFiles.forEach((file) => {
        dropdown.addOption(file, file);
      });
      if (mdFiles.length > 0) {
        if (((_a = this.lastConfig) == null ? void 0 : _a.sourceFile) && mdFiles.includes(this.lastConfig.sourceFile)) {
          this.config.sourceFile = this.lastConfig.sourceFile;
        } else if (!this.config.sourceFile || !mdFiles.includes(this.config.sourceFile)) {
          const maintext = mdFiles.find((f) => f.includes("maintext"));
          this.config.sourceFile = maintext || mdFiles[0];
        }
        dropdown.setValue(this.config.sourceFile);
      }
      dropdown.onChange((value) => {
        this.config.sourceFile = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Frontmatter").setDesc("Optional file to prepend (title, authors, etc.)").addDropdown((dropdown) => {
      var _a;
      this.frontmatterDropdown = dropdown;
      dropdown.addOption("", "None");
      mdFiles.forEach((file) => {
        dropdown.addOption(file, file);
      });
      if (((_a = this.lastConfig) == null ? void 0 : _a.frontmatterFile) && mdFiles.includes(this.lastConfig.frontmatterFile)) {
        this.config.frontmatterFile = this.lastConfig.frontmatterFile;
        dropdown.setValue(this.lastConfig.frontmatterFile);
      } else if (this.config.frontmatterFile && mdFiles.includes(this.config.frontmatterFile)) {
        dropdown.setValue(this.config.frontmatterFile);
      } else {
        const frontmatter = mdFiles.find((f) => f.includes("frontmatter"));
        if (frontmatter) {
          this.config.frontmatterFile = frontmatter;
          dropdown.setValue(frontmatter);
        }
      }
      dropdown.onChange((value) => {
        this.config.frontmatterFile = value || null;
      });
    });
    this.createSectionHeader(contentEl, "Output");
    const currentFormat = this.config.profile.startsWith("docx") ? "docx" : "pdf";
    new import_obsidian.Setting(contentEl).setName("Format").setDesc("Output document format").addDropdown((dropdown) => {
      this.formatDropdown = dropdown;
      dropdown.addOption("pdf", "PDF");
      dropdown.addOption("docx", "Word Document (DOCX)");
      dropdown.setValue(currentFormat);
      dropdown.onChange((value) => {
        this.updateProfilesForFormat(value);
        this.updateFormatOptions(value);
      });
    });
    new import_obsidian.Setting(contentEl).setName("Profile").setDesc("Document style and layout").addDropdown((dropdown) => {
      this.profileDropdown = dropdown;
      this.populateProfiles(dropdown, currentFormat);
      dropdown.setValue(this.config.profile);
      dropdown.onChange((value) => {
        this.config.profile = value;
      });
    });
    this.pngContainer = contentEl.createDiv();
    new import_obsidian.Setting(this.pngContainer).setName("Convert Figures to PNG").setDesc("Convert PDF figures to PNG for Word compatibility").addToggle((toggle) => {
      this.pngToggle = toggle;
      toggle.setValue(this.config.usePng);
      toggle.onChange((value) => {
        this.config.usePng = value;
      });
    });
    this.updateFormatOptions(currentFormat);
    this.createSectionHeader(contentEl, "Typography");
    new import_obsidian.Setting(contentEl).setName("Font").setDesc("Document typeface").addDropdown((dropdown) => {
      this.fontDropdown = dropdown;
      dropdown.addOption("", "Profile Default");
      Object.entries(FONT_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.font || "");
      dropdown.onChange((value) => {
        this.config.font = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Font Size").setDesc("Base font size").addDropdown((dropdown) => {
      this.fontSizeDropdown = dropdown;
      FONT_SIZES.forEach((size) => {
        dropdown.addOption(size, size);
      });
      dropdown.setValue(this.config.fontSize);
      dropdown.onChange((value) => {
        this.config.fontSize = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Line Spacing").setDesc("Override line spacing (leave as Profile Default to use profile setting)").addDropdown((dropdown) => {
      this.lineSpacingDropdown = dropdown;
      Object.entries(LINE_SPACING_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.lineSpacing);
      dropdown.onChange((value) => {
        this.config.lineSpacing = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Paragraph Style").setDesc("Indented, Gap, or Both").addDropdown((dropdown) => {
      this.paragraphStyleDropdown = dropdown;
      Object.entries(PARAGRAPH_STYLE_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.paragraphStyle);
      dropdown.onChange((value) => {
        this.config.paragraphStyle = value;
      });
    });
    new import_obsidian.Setting(contentEl).setName("Line Numbers").setDesc("Override line numbering (three-state: Profile Default / On / Off)").addDropdown((dropdown) => {
      this.lineNumbersDropdown = dropdown;
      dropdown.addOption("default", "Profile Default");
      dropdown.addOption("on", "On");
      dropdown.addOption("off", "Off");
      const currentValue = this.config.lineNumbers === null ? "default" : this.config.lineNumbers ? "on" : "off";
      dropdown.setValue(currentValue);
      dropdown.onChange((value) => {
        if (value === "default") {
          this.config.lineNumbers = null;
        } else {
          this.config.lineNumbers = value === "on";
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Numbered Headings").setDesc("Override heading numbering (three-state: Profile Default / On / Off)").addDropdown((dropdown) => {
      this.numberedHeadingsDropdown = dropdown;
      dropdown.addOption("default", "Profile Default");
      dropdown.addOption("on", "Numbered");
      dropdown.addOption("off", "Unnumbered");
      const currentValue = this.config.numberedHeadings === null ? "default" : this.config.numberedHeadings ? "on" : "off";
      dropdown.setValue(currentValue);
      dropdown.onChange((value) => {
        if (value === "default") {
          this.config.numberedHeadings = null;
        } else {
          this.config.numberedHeadings = value === "on";
        }
      });
    });
    new import_obsidian.Setting(contentEl).setName("Document Language").setDesc("Set document language for hyphenation and localization").addDropdown((dropdown) => {
      this.languageDropdown = dropdown;
      Object.entries(LANGUAGE_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.language);
      dropdown.onChange((value) => {
        this.config.language = value;
      });
    });
    this.createSectionHeader(contentEl, "Citations");
    const citationStyles = this.plugin.getCitationStyles();
    new import_obsidian.Setting(contentEl).setName("Citation Style").setDesc("Bibliography format").addDropdown((dropdown) => {
      this.citationDropdown = dropdown;
      Object.entries(citationStyles).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.citationStyle);
      dropdown.onChange((value) => {
        this.config.citationStyle = value;
      });
    });
    this.createSectionHeader(contentEl, "Supporting Information");
    new import_obsidian.Setting(contentEl).setName("Include SI References").setDesc("Add SI citations to the main bibliography").addToggle((toggle) => {
      this.siRefsToggle = toggle;
      toggle.setValue(this.config.includeSiRefs);
      toggle.onChange((value) => {
        this.config.includeSiRefs = value;
        this.siFileContainer.style.display = value ? "block" : "none";
      });
    });
    this.siFileContainer = contentEl.createDiv();
    new import_obsidian.Setting(this.siFileContainer).setName("SI File").setDesc("File containing SI references").addDropdown((dropdown) => {
      var _a;
      this.siFileDropdown = dropdown;
      mdFiles.forEach((file) => {
        dropdown.addOption(file, file);
      });
      if (((_a = this.lastConfig) == null ? void 0 : _a.siFile) && mdFiles.includes(this.lastConfig.siFile)) {
        this.config.siFile = this.lastConfig.siFile;
        dropdown.setValue(this.lastConfig.siFile);
      } else if (this.config.siFile && mdFiles.includes(this.config.siFile)) {
        dropdown.setValue(this.config.siFile);
      } else {
        const siFile = mdFiles.find((f) => f.includes("supp"));
        if (siFile) {
          this.config.siFile = siFile;
          dropdown.setValue(siFile);
        } else if (mdFiles.length > 0) {
          this.config.siFile = mdFiles[0];
          dropdown.setValue(mdFiles[0]);
        }
      }
      dropdown.onChange((value) => {
        this.config.siFile = value;
      });
    });
    this.siFileContainer.style.display = this.config.includeSiRefs ? "block" : "none";
    new import_obsidian.Setting(contentEl).setName("SI Formatting").setDesc("Apply S-prefixed figure/table numbering").addToggle((toggle) => {
      this.isSiToggle = toggle;
      toggle.setValue(this.config.isSi);
      toggle.onChange((value) => {
        this.config.isSi = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Restore Defaults").onClick(() => {
      this.restoreDefaults();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Build").setCta().onClick(() => {
      if (!this.config.sourceFile) {
        new import_obsidian.Notice("Please select a source file");
        return;
      }
      this.close();
      this.plugin.executeBuild(this.config);
    });
  }
  restoreDefaults() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    const mdFiles = this.plugin.getMarkdownFiles();
    const settings = this.plugin.settings;
    this.config.profile = settings.defaultProfile;
    this.config.font = settings.defaultFont;
    this.config.fontSize = settings.defaultFontSize;
    this.config.citationStyle = settings.defaultCitationStyle;
    this.config.lineSpacing = "";
    this.config.paragraphStyle = "";
    this.config.lineNumbers = null;
    this.config.numberedHeadings = null;
    this.config.language = "";
    this.config.usePng = false;
    this.config.includeSiRefs = false;
    this.config.isSi = false;
    const maintext = mdFiles.find((f) => f.includes("maintext"));
    this.config.sourceFile = maintext || mdFiles[0] || "";
    const frontmatter = mdFiles.find((f) => f.includes("frontmatter"));
    this.config.frontmatterFile = frontmatter || null;
    const siFile = mdFiles.find((f) => f.includes("supp"));
    this.config.siFile = siFile || mdFiles[0] || null;
    const currentFormat = this.config.profile.startsWith("docx") ? "docx" : "pdf";
    (_a = this.sourceDropdown) == null ? void 0 : _a.setValue(this.config.sourceFile);
    (_b = this.frontmatterDropdown) == null ? void 0 : _b.setValue(this.config.frontmatterFile || "");
    (_c = this.formatDropdown) == null ? void 0 : _c.setValue(currentFormat);
    this.populateProfiles(this.profileDropdown, currentFormat);
    (_d = this.profileDropdown) == null ? void 0 : _d.setValue(this.config.profile);
    (_e = this.fontDropdown) == null ? void 0 : _e.setValue(this.config.font);
    (_f = this.fontSizeDropdown) == null ? void 0 : _f.setValue(this.config.fontSize);
    (_g = this.lineSpacingDropdown) == null ? void 0 : _g.setValue(this.config.lineSpacing);
    (_h = this.paragraphStyleDropdown) == null ? void 0 : _h.setValue(this.config.paragraphStyle);
    (_i = this.lineNumbersDropdown) == null ? void 0 : _i.setValue("default");
    (_j = this.numberedHeadingsDropdown) == null ? void 0 : _j.setValue("default");
    (_k = this.languageDropdown) == null ? void 0 : _k.setValue(this.config.language);
    (_l = this.citationDropdown) == null ? void 0 : _l.setValue(this.config.citationStyle);
    (_m = this.pngToggle) == null ? void 0 : _m.setValue(this.config.usePng);
    (_n = this.siRefsToggle) == null ? void 0 : _n.setValue(this.config.includeSiRefs);
    (_o = this.siFileDropdown) == null ? void 0 : _o.setValue(this.config.siFile || "");
    (_p = this.isSiToggle) == null ? void 0 : _p.setValue(this.config.isSi);
    this.updateFormatOptions(currentFormat);
    this.siFileContainer.style.display = "none";
    new import_obsidian.Notice("Settings restored to defaults");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createSectionHeader(container, title) {
    container.createEl("h3", { text: title, cls: "setting-section-header" });
  }
  populateProfiles(dropdown, format) {
    dropdown.selectEl.empty();
    const profiles = this.plugin.getProfiles();
    const categories = /* @__PURE__ */ new Map();
    profiles.filter((p) => p.format === format).forEach((profile) => {
      var _a;
      if (!categories.has(profile.category)) {
        categories.set(profile.category, []);
      }
      (_a = categories.get(profile.category)) == null ? void 0 : _a.push(profile);
    });
    categories.forEach((profiles2, category) => {
      const optgroup = dropdown.selectEl.createEl("optgroup", { attr: { label: category } });
      profiles2.forEach((profile) => {
        optgroup.createEl("option", {
          value: profile.id,
          text: profile.name
        });
      });
    });
  }
  updateProfilesForFormat(format) {
    this.populateProfiles(this.profileDropdown, format);
    const defaultProfile = format === "docx" ? "docx-manuscript" : "pdf-default";
    this.profileDropdown.setValue(defaultProfile);
    this.config.profile = defaultProfile;
  }
  updateFormatOptions(format) {
    this.pngContainer.style.display = format === "docx" ? "block" : "none";
  }
};
var BuildOutputModal = class extends import_obsidian.Modal {
  constructor(app, fileName) {
    super(app);
    this.fileName = fileName;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("manuscript-build-output-modal");
    const header = contentEl.createDiv({ cls: "output-header" });
    header.createEl("h2", { text: "Building Manuscript" });
    this.statusEl = header.createEl("span", { cls: "build-status building", text: "Building..." });
    contentEl.createEl("p", { text: `Source: ${this.fileName}`, cls: "output-file-info" });
    this.outputEl = contentEl.createEl("pre", { cls: "build-output" });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Close").onClick(() => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  appendOutput(text, isError = false) {
    const span = this.outputEl.createEl("span", {
      text,
      cls: isError ? "output-error" : "output-text"
    });
    this.outputEl.scrollTop = this.outputEl.scrollHeight;
  }
  setSuccess() {
    this.statusEl.setText("\u2713 Complete");
    this.statusEl.removeClass("building");
    this.statusEl.addClass("success");
  }
  setError() {
    this.statusEl.setText("\u2717 Failed");
    this.statusEl.removeClass("building");
    this.statusEl.addClass("error");
  }
};
var ManuscriptBuildSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Manuscript Build Settings" });
    containerEl.createEl("h3", { text: "System", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("Path to Python executable (python3, python, or full path)").addText(
      (text) => text.setPlaceholder("python3").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value || "python3";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Build Script Path").setDesc("Path to build.py relative to vault root").addText(
      (text) => text.setPlaceholder("build.py").setValue(this.plugin.settings.buildScriptPath).onChange(async (value) => {
        this.plugin.settings.buildScriptPath = value || "build.py";
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Defaults", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Default Profile").setDesc("Default output profile for new builds").addDropdown((dropdown) => {
      this.plugin.getProfiles().forEach((profile) => {
        dropdown.addOption(profile.id, `${profile.name} (${profile.format.toUpperCase()})`);
      });
      dropdown.setValue(this.plugin.settings.defaultProfile);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultProfile = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default Font").setDesc("Default typeface for PDF builds").addDropdown((dropdown) => {
      dropdown.addOption("", "Profile Default");
      Object.entries(FONT_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.plugin.settings.defaultFont || "");
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultFont = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default Font Size").setDesc("Default font size for PDF builds").addDropdown((dropdown) => {
      FONT_SIZES.forEach((size) => {
        dropdown.addOption(size, size);
      });
      dropdown.setValue(this.plugin.settings.defaultFontSize);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultFontSize = value;
        await this.plugin.saveSettings();
      });
    });
    const citationStyles = this.plugin.getCitationStyles();
    new import_obsidian.Setting(containerEl).setName("Default Citation Style").setDesc("Default bibliography format").addDropdown((dropdown) => {
      Object.entries(citationStyles).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.plugin.settings.defaultCitationStyle);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultCitationStyle = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Add Citation Styles", cls: "setting-section-header" });
    const styleInfoEl = containerEl.createDiv({ cls: "setting-item-description citation-style-info" });
    styleInfoEl.innerHTML = `
			<p>To add a new citation style:</p>
			<ol>
				<li>Find your style at <strong>zotero.org/styles</strong></li>
				<li>Download the <code>.csl</code> file</li>
				<li>Place it in <code>resources/citation_styles/</code></li>
				<li>Reopen this dialog to see the new style</li>
			</ol>
		`;
    new import_obsidian.Setting(containerEl).setName("Browse Zotero Styles").setDesc("Open the Zotero Style Repository to find citation styles").addButton(
      (button) => button.setButtonText("Open Zotero Styles").onClick(() => {
        window.open("https://www.zotero.org/styles", "_blank");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Open Styles Folder").setDesc("Open the folder where citation style files are stored").addButton(
      (button) => button.setButtonText("Open Folder").onClick(() => {
        this.plugin.openCitationStylesFolder();
      })
    );
    containerEl.createEl("h3", { text: "Behavior", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Show Notifications").setDesc("Display build status notifications").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
        this.plugin.settings.showNotifications = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-open Export Folder").setDesc("Open the export folder after successful builds").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoOpenExport).onChange(async (value) => {
        this.plugin.settings.autoOpenExport = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Actions", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Open Export Folder").setDesc("Open the folder containing built documents").addButton(
      (button) => button.setButtonText("Open").onClick(() => {
        this.plugin.openExportFolder();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test Python").setDesc("Verify Python is accessible").addButton(
      (button) => button.setButtonText("Test").onClick(() => {
        this.testPython();
      })
    );
  }
  testPython() {
    var _a, _b;
    const { spawn: spawn2 } = require("child_process");
    const process2 = spawn2(this.plugin.settings.pythonPath, ["--version"]);
    let output = "";
    (_a = process2.stdout) == null ? void 0 : _a.on("data", (data) => {
      output += data.toString();
    });
    (_b = process2.stderr) == null ? void 0 : _b.on("data", (data) => {
      output += data.toString();
    });
    process2.on("close", (code) => {
      if (code === 0) {
        new import_obsidian.Notice(`\u2713 Python found: ${output.trim()}`);
      } else {
        new import_obsidian.Notice(`\u2717 Python not found at: ${this.plugin.settings.pythonPath}`);
      }
    });
    process2.on("error", () => {
      new import_obsidian.Notice(`\u2717 Python not found at: ${this.plugin.settings.pythonPath}`);
    });
  }
};
