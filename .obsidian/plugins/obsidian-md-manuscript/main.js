/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ManuscriptBuildPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  pythonPath: "python3",
  buildScriptPath: "",
  // Empty defaults to internal script
  bibliographyPath: "references.json",
  defaultProfile: "pdf-default",
  defaultFont: "",
  defaultFontSize: "11pt",
  defaultCitationStyle: "vancouver",
  defaultVisualizeCaptions: false,
  defaultCaptionStyle: "plain",
  showNotifications: true,
  autoOpenExport: false
};
var FONT_PRESETS = {
  libertinus: "Libertinus (Default)",
  "libertinus-serif": "Libertinus Serif",
  "libertinus-sans": "Libertinus Sans",
  inter: "Inter",
  "ibm-plex-sans": "IBM Plex Sans",
  "ibm-plex-serif": "IBM Plex Serif",
  switzer: "Switzer",
  times: "Times/TeX Gyre Termes",
  palatino: "Palatino/TeX Gyre Pagella",
  arial: "Arial",
  helvetica: "Helvetica-like (TeX Gyre Heros)",
  charter: "Charter",
  "computer-modern": "LaTeX Default (Compatibility)"
};
var FONT_SIZES = ["9pt", "10pt", "11pt", "12pt", "13pt", "14pt", "15pt", "16pt"];
var LINE_SPACING_PRESETS = {
  "": "Profile Default",
  single: "Single (1.0)",
  compact: "Compact (1.15)",
  normal: "Normal (1.25)",
  relaxed: "Relaxed (1.5)",
  double: "Double (2.0)"
};
var PARAGRAPH_STYLE_PRESETS = {
  "": "Profile Default",
  indent: "Indented (American)",
  gap: "Gap (European)",
  both: "Gap + Indent (Both)"
};
var LANGUAGE_PRESETS = {
  "": "Default (English)",
  en: "English",
  de: "German (Deutsch)",
  fr: "French (Fran\xE7ais)",
  es: "Spanish (Espa\xF1ol)",
  it: "Italian (Italiano)",
  pt: "Portuguese (Portugu\xEAs)",
  nl: "Dutch (Nederlands)",
  pl: "Polish (Polski)",
  ru: "Russian (\u0420\u0443\u0441\u0441\u043A\u0438\u0439)",
  zh: "Chinese (\u4E2D\u6587)",
  ja: "Japanese (\u65E5\u672C\u8A9E)"
};
var PAPER_SIZE_PRESETS = {
  "": "Profile Default",
  a4: "A4",
  letter: "US Letter"
};
var MARGIN_PRESETS = {
  "": { name: "Profile Default", top: "", bottom: "", left: "", right: "" },
  standard: { name: "Standard (2.5cm)", top: "2.5cm", bottom: "2.5cm", left: "2.5cm", right: "2.5cm" },
  narrow: { name: "Narrow (1.27cm)", top: "1.27cm", bottom: "1.27cm", left: "1.27cm", right: "1.27cm" },
  wide: { name: "Wide (3.0cm)", top: "3cm", bottom: "3cm", left: "3cm", right: "3cm" },
  custom: { name: "Custom", top: "", bottom: "", left: "", right: "" }
};
var CITATION_STYLE_NAMES = {
  vancouver: "Vancouver",
  nature: "Nature",
  cell: "Cell",
  science: "Science",
  pnas: "PNAS",
  plos: "PLOS",
  apa: "APA 7th Edition",
  "apa-7th-edition": "APA 7th Edition",
  chicago: "Chicago Author-Date",
  "chicago-author-date": "Chicago Author-Date",
  "acs-synthetic-biology": "ACS Synthetic Biology",
  "angewandte-chemie": "Angewandte Chemie",
  "nucleic-acids-research": "Nucleic Acids Research"
};
var FALLBACK_PROFILES = [
  { id: "docx-manuscript", name: "Word Manuscript", format: "docx", category: "General" },
  { id: "pdf-default", name: "PDF Default", format: "pdf", category: "General" }
];
var ManuscriptBuildPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.buildProcess = null;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("file-output", "Build Manuscript", async () => {
      const lastConfig = await this.loadLastBuildConfig();
      new BuildModal(this.app, this, lastConfig).open();
    });
    this.addCommand({
      id: "open-build-modal",
      name: "Open Build Dialog",
      callback: async () => {
        const lastConfig = await this.loadLastBuildConfig();
        new BuildModal(this.app, this, lastConfig).open();
      }
    });
    this.addCommand({
      id: "build-current-file",
      name: "Build Current File",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile && activeFile.extension === "md") {
          this.buildWithDefaults(activeFile.path);
        } else {
          new import_obsidian.Notice("No markdown file is currently active");
        }
      }
    });
    this.addSettingTab(new ManuscriptBuildSettingTab(this.app, this));
  }
  onunload() {
    if (this.buildProcess) {
      this.buildProcess.kill();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getVaultPath() {
    const adapter = this.app.vault.adapter;
    return adapter.basePath || "";
  }
  getBuildScriptPath() {
    if (this.settings.buildScriptPath && this.settings.buildScriptPath.trim() !== "") {
      return this.settings.buildScriptPath;
    }
    return path.join(this.manifest.dir || "", "resources", "build.py");
  }
  getInstallFontsScriptPath() {
    return path.join(this.manifest.dir || "", "resources", "install-fonts.py");
  }
  async installCssSnippets() {
    const fs = require("fs");
    const vaultPath = this.getVaultPath();
    const snippetsDir = path.join(vaultPath, ".obsidian", "snippets");
    const resourcesDir = path.join(vaultPath, this.manifest.dir || "", "resources");
    if (!fs.existsSync(resourcesDir)) {
      new import_obsidian.Notice("\u274C Resources directory not found!");
      return;
    }
    if (!fs.existsSync(snippetsDir)) {
      fs.mkdirSync(snippetsDir, { recursive: true });
    }
    let count = 0;
    try {
      const files = fs.readdirSync(resourcesDir);
      for (const file of files) {
        if (file.endsWith(".css")) {
          const src = path.join(resourcesDir, file);
          const dest = path.join(snippetsDir, file);
          fs.copyFileSync(src, dest);
          count++;
        }
      }
      new import_obsidian.Notice(`\u2713 Installed ${count} CSS snippets to .obsidian/snippets/`);
      new import_obsidian.Notice("Please enable them in Settings > Appearance > CSS Snippets");
    } catch (e) {
      console.error("Failed to install snippets:", e);
      new import_obsidian.Notice("\u274C Failed to install snippets");
    }
  }
  installFonts() {
    const scriptPath = this.getInstallFontsScriptPath();
    const vaultPath = this.getVaultPath();
    new import_obsidian.Notice("Launching font installer...");
    let cmd = "";
    let args = [];
    if (process.platform === "darwin") {
      cmd = "open";
      args = ["-a", "Terminal", scriptPath];
      const command = `python "${scriptPath}"`;
      navigator.clipboard.writeText(command);
      new import_obsidian.Notice("Command copied to clipboard! Paste in terminal.");
      return;
    } else if (process.platform === "win32") {
      const command = `python "${scriptPath}"`;
      navigator.clipboard.writeText(command);
      new import_obsidian.Notice("Command copied to clipboard! Paste in PowerShell.");
      return;
    } else {
      const command = `python3 "${scriptPath}"`;
      navigator.clipboard.writeText(command);
      new import_obsidian.Notice("Command copied to clipboard! Paste in terminal.");
      return;
    }
  }
  getMarkdownFiles() {
    const files = this.app.vault.getMarkdownFiles();
    return files.filter((f) => !f.name.startsWith("_") && f.name.toLowerCase() !== "readme.md").sort((a, b) => {
      const aIsRoot = !a.path.includes("/");
      const bIsRoot = !b.path.includes("/");
      if (aIsRoot && !bIsRoot)
        return -1;
      if (!aIsRoot && bIsRoot)
        return 1;
      return a.path.localeCompare(b.path);
    }).map((f) => f.path);
  }
  getCitationStyles() {
    const styles = {};
    const vaultPath = this.getVaultPath();
    const stylesDir = path.join(vaultPath, this.manifest.dir || "", "resources", "citation_styles");
    try {
      const fs = require("fs");
      if (fs.existsSync(stylesDir)) {
        const files = fs.readdirSync(stylesDir);
        files.filter((f) => f.endsWith(".csl")).forEach((f) => {
          const id = f.replace(".csl", "");
          const displayName = CITATION_STYLE_NAMES[id] || this.formatStyleName(id);
          styles[id] = displayName;
        });
      }
    } catch (e) {
      console.error("Failed to read citation styles:", e);
    }
    if (Object.keys(styles).length === 0) {
      return { vancouver: "Vancouver", nature: "Nature" };
    }
    const sorted = {};
    Object.entries(styles).sort((a, b) => a[1].localeCompare(b[1])).forEach(([k, v]) => {
      sorted[k] = v;
    });
    return sorted;
  }
  formatStyleName(id) {
    return id.split("-").map((word) => {
      if (word.length <= 3 && word === word.toLowerCase()) {
        return word.toUpperCase();
      }
      return word.charAt(0).toUpperCase() + word.slice(1);
    }).join(" ");
  }
  getProfiles() {
    const profiles = [];
    const vaultPath = this.getVaultPath();
    const profilesDir = path.join(vaultPath, this.manifest.dir || "", "resources", "profiles");
    try {
      const fs = require("fs");
      if (fs.existsSync(profilesDir)) {
        const files = fs.readdirSync(profilesDir);
        files.filter((f) => f.endsWith(".yaml") && !f.startsWith("_")).forEach((f) => {
          const id = f.replace(".yaml", "");
          const filePath = path.join(profilesDir, f);
          try {
            const content = fs.readFileSync(filePath, "utf8");
            const profileInfo = this.parseProfileYaml(id, content);
            if (profileInfo) {
              profiles.push(profileInfo);
            }
          } catch (e) {
            console.error(`Failed to read profile ${f}:`, e);
          }
        });
      }
    } catch (e) {
      console.error("Failed to read profiles directory:", e);
    }
    if (profiles.length === 0) {
      return FALLBACK_PROFILES;
    }
    return profiles.sort((a, b) => {
      var _a, _b;
      const catOrder = { General: 0, Thesis: 1, Journals: 2 };
      const catA = (_a = catOrder[a.category]) != null ? _a : 99;
      const catB = (_b = catOrder[b.category]) != null ? _b : 99;
      if (catA !== catB)
        return catA - catB;
      return a.name.localeCompare(b.name);
    });
  }
  parseProfileYaml(id, content) {
    const nameMatch = content.match(/^\s*name:\s*["']?([^"'\n]+)["']?\s*$/m);
    const formatMatch = content.match(/^\s*format:\s*["']?([^"'\n]+)["']?\s*$/m);
    if (!nameMatch) {
      return {
        id,
        name: this.formatStyleName(id),
        format: id.startsWith("docx") ? "docx" : "pdf",
        category: this.inferCategory(id)
      };
    }
    const name = nameMatch[1].trim();
    const format = formatMatch ? formatMatch[1].trim() : id.startsWith("docx") ? "docx" : "pdf";
    return {
      id,
      name,
      format,
      category: this.inferCategory(id)
    };
  }
  inferCategory(id) {
    if (id.includes("thesis"))
      return "Thesis";
    if (id.includes("nature") || id.includes("cell") || id.includes("journal"))
      return "Journals";
    return "General";
  }
  async buildWithDefaults(sourceFile) {
    const config = {
      sourceFile,
      frontmatterFile: null,
      profile: this.settings.defaultProfile,
      usePng: false,
      includeSiRefs: false,
      siFile: null,
      isSi: false,
      texMode: "",
      font: this.settings.defaultFont,
      fontSize: this.settings.defaultFontSize,
      citationStyle: this.settings.defaultCitationStyle,
      lineSpacing: "",
      paragraphStyle: "",
      lineNumbers: null,
      pageNumbers: null,
      numberedHeadings: null,
      language: "",
      figureFormat: "png",
      figureBackground: "white",
      paperSize: "",
      margins: "",
      marginTop: "",
      marginBottom: "",
      marginLeft: "",
      marginRight: "",
      visualizeCaptions: false,
      captionStyle: "plain",
      digitalGarden: false
    };
    this.executeBuild(config);
  }
  async loadLastBuildConfig() {
    try {
      const configPath = path.join(this.getVaultPath(), ".build_config.json");
      const fs = require("fs");
      if (fs.existsSync(configPath)) {
        const content = fs.readFileSync(configPath, "utf8");
        const data = JSON.parse(content);
        return {
          sourceFile: data.source_file || "",
          frontmatterFile: data.frontmatter_file || null,
          profile: data.profile || this.settings.defaultProfile,
          usePng: data.use_png || false,
          includeSiRefs: data.include_si_refs || false,
          siFile: data.si_file || null,
          isSi: data.is_si || false,
          texMode: data.tex_mode || (data.output_tex ? "portable" : ""),
          font: data.font !== void 0 ? data.font : this.settings.defaultFont,
          fontSize: data.fontsize || this.settings.defaultFontSize,
          citationStyle: data.citation_style || this.settings.defaultCitationStyle,
          lineSpacing: data.linespacing || "",
          paragraphStyle: data.paragraph_style || "",
          lineNumbers: data.linenumbers !== void 0 ? data.linenumbers : null,
          pageNumbers: data.pagenumbers !== void 0 ? data.pagenumbers : null,
          numberedHeadings: data.numbered_headings !== void 0 ? data.numbered_headings : null,
          language: data.language || "",
          figureFormat: data.figure_format || "png",
          figureBackground: data.figure_background || "white",
          paperSize: data.papersize || "",
          margins: data.margins || "",
          marginTop: data.margin_top || "",
          marginBottom: data.margin_bottom || "",
          marginLeft: data.margin_left || "",
          marginRight: data.margin_right || "",
          visualizeCaptions: data.visualize_captions || false,
          captionStyle: data.caption_style || "plain",
          digitalGarden: data.digital_garden || false
        };
      }
    } catch (e) {
      console.error("Failed to load last build config:", e);
    }
    return null;
  }
  saveBuildConfig(config) {
    const fs = require("fs");
    const configPath = path.join(this.getVaultPath(), ".build_config.json");
    const data = {
      source_file: config.sourceFile,
      frontmatter_file: config.frontmatterFile,
      profile: config.profile,
      use_png: config.usePng,
      include_si_refs: config.includeSiRefs,
      si_file: config.siFile,
      is_si: config.isSi,
      tex_mode: config.texMode || null,
      font: config.font || null,
      fontsize: config.fontSize,
      citation_style: config.citationStyle,
      linespacing: config.lineSpacing || null,
      paragraph_style: config.paragraphStyle || null,
      linenumbers: config.lineNumbers,
      pagenumbers: config.pageNumbers,
      numbered_headings: config.numberedHeadings,
      language: config.language || null,
      figure_format: config.figureFormat || null,
      figure_background: config.figureBackground || null,
      papersize: config.paperSize || null,
      margins: config.margins || null,
      margin_top: config.marginTop || null,
      margin_bottom: config.marginBottom || null,
      margin_left: config.marginLeft || null,
      margin_right: config.marginRight || null,
      visualize_captions: config.visualizeCaptions || false,
      caption_style: config.captionStyle || "plain",
      digital_garden: config.digitalGarden || false
    };
    try {
      fs.writeFileSync(configPath, JSON.stringify(data, null, 2));
    } catch (e) {
      console.error("Failed to save build config:", e);
    }
  }
  executeBuild(config) {
    var _a, _b;
    this.saveBuildConfig(config);
    const vaultPath = this.getVaultPath();
    const args = this.buildCommandArgs(config);
    if (this.settings.showNotifications) {
      new import_obsidian.Notice(`Building ${config.sourceFile}...`);
    }
    const outputModal = new BuildOutputModal(this.app, config.sourceFile);
    outputModal.open();
    this.buildProcess = (0, import_child_process.spawn)(this.settings.pythonPath, args, {
      cwd: vaultPath,
      env: { ...process.env, PAGER: "cat" }
    });
    let stdout = "";
    let stderr = "";
    (_a = this.buildProcess.stdout) == null ? void 0 : _a.on("data", (data) => {
      const text = data.toString();
      stdout += text;
      outputModal.appendOutput(text);
    });
    (_b = this.buildProcess.stderr) == null ? void 0 : _b.on("data", (data) => {
      const text = data.toString();
      stderr += text;
      outputModal.appendOutput(text, true);
    });
    this.buildProcess.on("close", (code) => {
      this.buildProcess = null;
      if (code === 0) {
        outputModal.setSuccess();
        if (this.settings.showNotifications) {
          new import_obsidian.Notice("\u2713 Build complete!");
        }
        if (this.settings.autoOpenExport) {
          this.openExportFolder();
        }
      } else {
        outputModal.setError();
        if (this.settings.showNotifications) {
          new import_obsidian.Notice("\u2717 Build failed. Check output for details.");
        }
      }
    });
    this.buildProcess.on("error", (err) => {
      this.buildProcess = null;
      outputModal.appendOutput(`
Error: ${err.message}`, true);
      outputModal.setError();
      new import_obsidian.Notice(`Build error: ${err.message}`);
    });
  }
  buildCommandArgs(config) {
    const scriptPath = this.getBuildScriptPath();
    const args = [scriptPath];
    args.push(`--source=${config.sourceFile}`);
    if (config.frontmatterFile) {
      args.push(`--frontmatter=${config.frontmatterFile}`);
    }
    args.push(`--profile=${config.profile}`);
    if (config.usePng) {
      args.push("--png");
    }
    if (config.includeSiRefs) {
      args.push("--include-si-refs");
      if (config.siFile) {
        args.push(`--si-file=${config.siFile}`);
      }
    }
    if (config.isSi) {
      args.push("--si");
    }
    if (config.texMode === "source") {
      args.push("--tex-source");
    } else if (config.texMode === "portable") {
      args.push("--tex");
    } else if (config.texMode === "body") {
      args.push("--tex-body");
    }
    if (config.font) {
      args.push(`--font=${config.font}`);
    }
    if (config.fontSize) {
      args.push(`--fontsize=${config.fontSize}`);
    }
    if (config.lineSpacing) {
      args.push(`--linespacing=${config.lineSpacing}`);
    }
    if (config.paragraphStyle) {
      args.push(`--paragraph-style=${config.paragraphStyle}`);
    }
    if (config.lineNumbers === true) {
      args.push("--linenumbers");
    } else if (config.lineNumbers === false) {
      args.push("--no-linenumbers");
    }
    if (config.pageNumbers === true) {
      args.push("--pagenumbers");
    } else if (config.pageNumbers === false) {
      args.push("--no-pagenumbers");
    }
    if (config.numberedHeadings === true) {
      args.push("--numbered-headings");
    } else if (config.numberedHeadings === false) {
      args.push("--no-numbered-headings");
    }
    if (config.language) {
      args.push(`--lang=${config.language}`);
    }
    if (config.paperSize) {
      args.push(`--papersize=${config.paperSize}`);
    }
    if (config.marginTop) {
      args.push(`--margin-top=${config.marginTop}`);
    }
    if (config.marginBottom) {
      args.push(`--margin-bottom=${config.marginBottom}`);
    }
    if (config.marginLeft) {
      args.push(`--margin-left=${config.marginLeft}`);
    }
    if (config.marginRight) {
      args.push(`--margin-right=${config.marginRight}`);
    }
    if (config.citationStyle) {
      args.push(`--csl=${config.citationStyle}`);
    }
    if (config.profile === "md-flattened") {
      if (config.digitalGarden) {
        args.push("--digital-garden");
      }
      if (config.figureFormat) {
        args.push(`--figure-format=${config.figureFormat}`);
      }
      if (config.figureBackground) {
        args.push(`--figure-bg=${config.figureBackground}`);
      }
      if (config.visualizeCaptions) {
        args.push("--captions");
      }
      if (config.captionStyle === "html") {
        args.push("--html-captions");
      }
    }
    return args;
  }
  openExportFolder() {
    const exportPath = path.join(this.getVaultPath(), "export");
    const { shell } = require("electron");
    shell.openPath(exportPath);
  }
  openCitationStylesFolder() {
    const stylesPath = path.join(this.getVaultPath(), this.manifest.dir || "", "resources", "citation_styles");
    const fs = require("fs");
    if (!fs.existsSync(stylesPath)) {
      fs.mkdirSync(stylesPath, { recursive: true });
    }
    const { shell } = require("electron");
    shell.openPath(stylesPath);
  }
  getBuildCommand() {
    const scriptPath = this.getBuildScriptPath();
    const command = `python "${scriptPath}"`;
    navigator.clipboard.writeText(command);
    new import_obsidian.Notice("Command copied to clipboard!");
  }
};
var FileSuggestModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, files, onChoose) {
    super(app);
    this.files = files;
    this.onChoose = onChoose;
  }
  getItems() {
    return this.files;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.onChoose(item);
  }
};
var BuildModal = class extends import_obsidian.Modal {
  constructor(app, plugin, lastConfig = null) {
    super(app);
    this.lastConfig = null;
    this.showAllFiles = false;
    this.allFiles = [];
    this.plugin = plugin;
    this.lastConfig = lastConfig;
    if (lastConfig) {
      this.config = { ...lastConfig };
    } else {
      this.config = {
        sourceFile: "",
        frontmatterFile: null,
        profile: plugin.settings.defaultProfile,
        usePng: false,
        includeSiRefs: false,
        siFile: null,
        isSi: false,
        texMode: "",
        font: plugin.settings.defaultFont,
        fontSize: plugin.settings.defaultFontSize,
        citationStyle: plugin.settings.defaultCitationStyle,
        lineSpacing: "",
        paragraphStyle: "",
        lineNumbers: null,
        pageNumbers: null,
        numberedHeadings: null,
        language: "",
        figureFormat: "png",
        figureBackground: "white",
        paperSize: "",
        margins: "",
        marginTop: "",
        marginBottom: "",
        marginLeft: "",
        marginRight: "",
        visualizeCaptions: plugin.settings.defaultVisualizeCaptions,
        captionStyle: plugin.settings.defaultCaptionStyle,
        digitalGarden: false
      };
    }
  }
  updateFileSelectors() {
    const visibleFiles = this.showAllFiles ? this.allFiles : this.allFiles.filter((f) => !f.includes("/"));
    const update = (button, currentValue, allowNone = false) => {
      if (!button)
        return;
      const displayValue = currentValue ? currentValue : allowNone ? "None" : "Select File...";
      button.setButtonText(displayValue);
    };
    update(this.sourceButton, this.config.sourceFile);
    update(this.frontmatterButton, this.config.frontmatterFile, true);
    update(this.siFileButton, this.config.siFile, true);
  }
  onOpen() {
    var _a, _b;
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("manuscript-build-modal");
    contentEl.createEl("h2", { text: "Build Manuscript", cls: "modal-title" });
    this.allFiles = this.plugin.getMarkdownFiles();
    const mdFiles = this.allFiles;
    if (mdFiles.length > 0) {
      if (((_a = this.lastConfig) == null ? void 0 : _a.sourceFile) && mdFiles.includes(this.lastConfig.sourceFile)) {
        this.config.sourceFile = this.lastConfig.sourceFile;
      } else if (!this.config.sourceFile || !mdFiles.includes(this.config.sourceFile)) {
        const maintext = mdFiles.find((f) => f.includes("maintext"));
        this.config.sourceFile = maintext || mdFiles[0];
      }
      if (this.lastConfig && this.lastConfig.frontmatterFile !== void 0) {
        this.config.frontmatterFile = this.lastConfig.frontmatterFile;
      } else if (this.config.frontmatterFile && mdFiles.includes(this.config.frontmatterFile)) {
      } else {
        const frontmatter = mdFiles.find((f) => f.includes("frontmatter"));
        if (frontmatter) {
          this.config.frontmatterFile = frontmatter;
        }
      }
      if (((_b = this.lastConfig) == null ? void 0 : _b.siFile) && mdFiles.includes(this.lastConfig.siFile)) {
        this.config.siFile = this.lastConfig.siFile;
      } else if (this.config.siFile && mdFiles.includes(this.config.siFile)) {
      } else {
        const siFile = mdFiles.find((f) => f.includes("supp"));
        if (siFile) {
          this.config.siFile = siFile;
        } else if (mdFiles.length > 0) {
          this.config.siFile = mdFiles[0];
        }
      }
    }
    this.createSectionHeader(contentEl, "Document");
    new import_obsidian.Setting(contentEl).setName("Show files in subfolders").setDesc("Toggle visibility of files located in subdirectories").addToggle((toggle) => {
      toggle.setValue(this.showAllFiles);
      toggle.onChange((value) => {
        this.showAllFiles = value;
        this.updateFileSelectors();
      });
    });
    new import_obsidian.Setting(contentEl).setName("Source File").setDesc("The main document to build").addButton((btn) => {
      this.sourceButton = btn;
      btn.onClick(() => {
        const visibleFiles = this.showAllFiles ? this.allFiles : this.allFiles.filter((f) => !f.includes("/"));
        new FileSuggestModal(this.app, visibleFiles, (file) => {
          this.config.sourceFile = file;
          this.updateFileSelectors();
        }).open();
      });
    });
    new import_obsidian.Setting(contentEl).setName("Frontmatter").setDesc("Optional file to prepend (title, authors, etc.)").addButton((btn) => {
      this.frontmatterButton = btn;
      btn.onClick(() => {
        const visibleFiles = this.showAllFiles ? this.allFiles : this.allFiles.filter((f) => !f.includes("/"));
        const options = ["None", ...visibleFiles];
        new FileSuggestModal(this.app, options, (file) => {
          this.config.frontmatterFile = file === "None" ? null : file;
          this.updateFileSelectors();
        }).open();
      });
    });
    this.createSectionHeader(contentEl, "Output");
    const outputGrid = contentEl.createDiv({ cls: "manuscript-settings-grid" });
    let currentFormat = this.config.profile.startsWith("docx") ? "docx" : this.config.profile === "md-flattened" ? "md" : "pdf";
    if (currentFormat === "pdf" && this.config.texMode) {
      currentFormat = "latex";
    }
    new import_obsidian.Setting(outputGrid).setClass("manuscript-setting-compact").setName("Format").setDesc("Output document format").addDropdown((dropdown) => {
      this.formatDropdown = dropdown;
      dropdown.addOption("pdf", "PDF");
      dropdown.addOption("latex", "LaTeX");
      dropdown.addOption("docx", "Word Document (DOCX)");
      dropdown.addOption("md", "Flattened Markdown (Digital Garden)");
      dropdown.setValue(currentFormat);
      dropdown.onChange((value) => {
        let profileFormat2 = value;
        if (value === "latex") {
          profileFormat2 = "pdf";
        } else if (value === "md") {
          this.config.profile = "md-flattened";
        }
        if (value !== "latex") {
          this.config.texMode = "";
        } else if (!this.config.texMode) {
          this.config.texMode = "portable";
        }
        if (value !== "md") {
          this.updateProfilesForFormat(profileFormat2);
        }
        this.updateFormatOptions(value);
      });
    });
    this.latexModeContainer = outputGrid.createDiv();
    this.latexModeContainer.addClass("manuscript-setting-compact");
    new import_obsidian.Setting(this.latexModeContainer).setClass("manuscript-setting-compact").setName("LaTeX Mode").setDesc("Choose how LaTeX is exported").addDropdown((dropdown) => {
      dropdown.addOption("source", "LaTeX Source (profile exact)");
      dropdown.addOption("portable", "Portable LaTeX");
      dropdown.addOption("body", "Body-only (paste into journal templates)");
      dropdown.setValue(this.config.texMode || "portable");
      dropdown.onChange((value) => {
        this.config.texMode = value;
      });
    });
    const profileFormat = currentFormat === "latex" ? "pdf" : currentFormat;
    new import_obsidian.Setting(outputGrid).setClass("manuscript-setting-compact").setName("Profile").setDesc("Document style and layout").addDropdown((dropdown) => {
      this.profileDropdown = dropdown;
      this.populateProfiles(dropdown, profileFormat);
      dropdown.setValue(this.config.profile);
      dropdown.onChange((value) => {
        this.config.profile = value;
      });
    });
    this.pngContainer = outputGrid.createDiv();
    new import_obsidian.Setting(this.pngContainer).setClass("manuscript-setting-compact").setName("Convert Figures to PNG").setDesc("Convert PDF figures to PNG for Word compatibility").addToggle((toggle) => {
      this.pngToggle = toggle;
      toggle.setValue(this.config.usePng);
      toggle.onChange((value) => {
        this.config.usePng = value;
      });
    });
    this.flattenedMdContainer = contentEl.createDiv({ cls: "manuscript-settings-grid" });
    new import_obsidian.Setting(this.flattenedMdContainer).setClass("manuscript-setting-compact").setName("Digital Garden Mode").setDesc("Build separate linked pages").addToggle((toggle) => {
      this.digitalGardenToggle = toggle;
      toggle.setValue(this.config.digitalGarden || false);
      toggle.onChange((value) => {
        this.config.digitalGarden = value;
      });
    });
    new import_obsidian.Setting(this.flattenedMdContainer).setClass("manuscript-setting-compact").setName("Figure Format").setDesc("Output format for figures").addDropdown((dropdown) => {
      this.figureFormatDropdown = dropdown;
      dropdown.addOption("png", "PNG");
      dropdown.addOption("webp", "WebP");
      dropdown.addOption("jpg", "JPEG");
      dropdown.addOption("original", "Keep Original");
      dropdown.setValue(this.config.figureFormat || "png");
      dropdown.onChange((value) => {
        this.config.figureFormat = value;
        if (this.figureBackgroundContainer) {
          this.figureBackgroundContainer.style.display = value !== "original" ? "block" : "none";
        }
      });
    });
    this.figureBackgroundContainer = this.flattenedMdContainer.createDiv();
    new import_obsidian.Setting(this.figureBackgroundContainer).setClass("manuscript-setting-compact").setName("Figure Background").setDesc("Background color for converted figures").addDropdown((dropdown) => {
      this.figureBackgroundDropdown = dropdown;
      dropdown.addOption("white", "White");
      dropdown.addOption("transparent", "Transparent");
      dropdown.setValue(this.config.figureBackground || "white");
      dropdown.onChange((value) => {
        this.config.figureBackground = value;
      });
    });
    this.figureBackgroundContainer.style.display = this.config.figureFormat !== "original" ? "block" : "none";
    new import_obsidian.Setting(this.flattenedMdContainer).setClass("manuscript-setting-compact").setName("Visualize Captions").setDesc("Output visible captions below images (for digital gardens)").addToggle((toggle) => {
      this.visualizeCaptionsToggle = toggle;
      toggle.setValue(this.config.visualizeCaptions || false);
      toggle.onChange((value) => {
        this.config.visualizeCaptions = value;
      });
    });
    new import_obsidian.Setting(this.flattenedMdContainer).setClass("manuscript-setting-compact").setName("HTML Figures & Captions").setDesc("Use HTML <figure> tags to retain size/alignment").addToggle((toggle) => {
      this.captionStyleToggle = toggle;
      toggle.setValue(this.config.captionStyle === "html");
      toggle.onChange((value) => {
        this.config.captionStyle = value ? "html" : "plain";
      });
    });
    this.updateFormatOptions(currentFormat);
    this.typographySection = contentEl.createDiv();
    this.createSectionHeader(this.typographySection, "Typography");
    const typeGrid = this.typographySection.createDiv({ cls: "manuscript-settings-grid" });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Font").setDesc("Document typeface").addDropdown((dropdown) => {
      this.fontDropdown = dropdown;
      dropdown.addOption("", "Profile Default");
      Object.entries(FONT_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.font || "");
      dropdown.onChange((value) => {
        this.config.font = value;
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Font Size").setDesc("Base font size (Note: >12pt requires compatible profiles like Notes or Thesis)").addDropdown((dropdown) => {
      this.fontSizeDropdown = dropdown;
      FONT_SIZES.forEach((size) => {
        dropdown.addOption(size, size);
      });
      dropdown.setValue(this.config.fontSize);
      dropdown.onChange((value) => {
        this.config.fontSize = value;
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Line Spacing").setDesc("Override line spacing").addDropdown((dropdown) => {
      this.lineSpacingDropdown = dropdown;
      Object.entries(LINE_SPACING_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.lineSpacing);
      dropdown.onChange((value) => {
        this.config.lineSpacing = value;
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Paragraph Style").setDesc("Indented, Gap, or Both").addDropdown((dropdown) => {
      this.paragraphStyleDropdown = dropdown;
      Object.entries(PARAGRAPH_STYLE_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.paragraphStyle);
      dropdown.onChange((value) => {
        this.config.paragraphStyle = value;
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Paper Size").setDesc("Override paper size").addDropdown((dropdown) => {
      this.paperSizeDropdown = dropdown;
      Object.entries(PAPER_SIZE_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.paperSize);
      dropdown.onChange((value) => {
        this.config.paperSize = value;
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Margins").setDesc("Override document margins").addDropdown((dropdown) => {
      this.marginsDropdown = dropdown;
      Object.entries(MARGIN_PRESETS).forEach(([key, preset]) => {
        dropdown.addOption(key, preset.name);
      });
      dropdown.setValue(this.config.margins);
      dropdown.onChange((value) => {
        var _a2, _b2, _c, _d;
        this.config.margins = value;
        if (value && MARGIN_PRESETS[value] && value !== "custom") {
          const preset = MARGIN_PRESETS[value];
          this.config.marginTop = preset.top;
          this.config.marginBottom = preset.bottom;
          this.config.marginLeft = preset.left;
          this.config.marginRight = preset.right;
          (_a2 = this.marginTopInput) == null ? void 0 : _a2.setValue(preset.top);
          (_b2 = this.marginBottomInput) == null ? void 0 : _b2.setValue(preset.bottom);
          (_c = this.marginLeftInput) == null ? void 0 : _c.setValue(preset.left);
          (_d = this.marginRightInput) == null ? void 0 : _d.setValue(preset.right);
        }
      });
    });
    const setCustomMargins = () => {
      var _a2;
      this.config.margins = "custom";
      (_a2 = this.marginsDropdown) == null ? void 0 : _a2.setValue("custom");
    };
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Custom Margins").setDesc("Top, Bottom, Left, Right (e.g. 2cm, 1in)").addText((text) => {
      this.marginTopInput = text;
      text.setPlaceholder("Top").setValue(this.config.marginTop).onChange((v) => {
        this.config.marginTop = v;
        setCustomMargins();
      });
      text.inputEl.style.width = "65px";
    }).addText((text) => {
      this.marginBottomInput = text;
      text.setPlaceholder("Bottom").setValue(this.config.marginBottom).onChange((v) => {
        this.config.marginBottom = v;
        setCustomMargins();
      });
      text.inputEl.style.width = "65px";
    }).addText((text) => {
      this.marginLeftInput = text;
      text.setPlaceholder("Left").setValue(this.config.marginLeft).onChange((v) => {
        this.config.marginLeft = v;
        setCustomMargins();
      });
      text.inputEl.style.width = "65px";
    }).addText((text) => {
      this.marginRightInput = text;
      text.setPlaceholder("Right").setValue(this.config.marginRight).onChange((v) => {
        this.config.marginRight = v;
        setCustomMargins();
      });
      text.inputEl.style.width = "65px";
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Line Numbers").setDesc("Three-state: Default / On / Off").addDropdown((dropdown) => {
      this.lineNumbersDropdown = dropdown;
      dropdown.addOption("default", "Profile Default");
      dropdown.addOption("on", "On");
      dropdown.addOption("off", "Off");
      const currentValue = this.config.lineNumbers === null ? "default" : this.config.lineNumbers ? "on" : "off";
      dropdown.setValue(currentValue);
      dropdown.onChange((value) => {
        if (value === "default") {
          this.config.lineNumbers = null;
        } else {
          this.config.lineNumbers = value === "on";
        }
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Page Numbers").setDesc("Three-state: Default / On / Off").addDropdown((dropdown) => {
      this.pageNumbersDropdown = dropdown;
      dropdown.addOption("default", "Profile Default");
      dropdown.addOption("on", "On");
      dropdown.addOption("off", "Off");
      const currentValue = this.config.pageNumbers === null ? "default" : this.config.pageNumbers ? "on" : "off";
      dropdown.setValue(currentValue);
      dropdown.onChange((value) => {
        if (value === "default") {
          this.config.pageNumbers = null;
        } else {
          this.config.pageNumbers = value === "on";
        }
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Numbered Headings").setDesc("Three-state: Default / On / Off").addDropdown((dropdown) => {
      this.numberedHeadingsDropdown = dropdown;
      dropdown.addOption("default", "Profile Default");
      dropdown.addOption("on", "Numbered");
      dropdown.addOption("off", "Unnumbered");
      const currentValue = this.config.numberedHeadings === null ? "default" : this.config.numberedHeadings ? "on" : "off";
      dropdown.setValue(currentValue);
      dropdown.onChange((value) => {
        if (value === "default") {
          this.config.numberedHeadings = null;
        } else {
          this.config.numberedHeadings = value === "on";
        }
      });
    });
    new import_obsidian.Setting(typeGrid).setClass("manuscript-setting-compact").setName("Document Language").setDesc("Hyphenation and localization").addDropdown((dropdown) => {
      this.languageDropdown = dropdown;
      Object.entries(LANGUAGE_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.language);
      dropdown.onChange((value) => {
        this.config.language = value;
      });
    });
    this.citationsSection = contentEl.createDiv();
    this.createSectionHeader(this.citationsSection, "Citations");
    const citationStyles = this.plugin.getCitationStyles();
    new import_obsidian.Setting(this.citationsSection).setName("Citation Style").setDesc("Bibliography format").addDropdown((dropdown) => {
      this.citationDropdown = dropdown;
      Object.entries(citationStyles).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.config.citationStyle);
      dropdown.onChange((value) => {
        this.config.citationStyle = value;
      });
    });
    this.createSectionHeader(contentEl, "Supporting Information");
    const siGrid = contentEl.createDiv({ cls: "manuscript-settings-grid" });
    new import_obsidian.Setting(siGrid).setClass("manuscript-setting-compact").setName("Include SI References").setDesc("Add SI citations to main bib").addToggle((toggle) => {
      this.siRefsToggle = toggle;
      toggle.setValue(this.config.includeSiRefs);
      toggle.onChange((value) => {
        this.config.includeSiRefs = value;
        this.siFileContainer.style.display = value ? "block" : "none";
      });
    });
    this.siFileContainer = siGrid.createDiv();
    new import_obsidian.Setting(this.siFileContainer).setClass("manuscript-setting-compact").setName("SI File").setDesc("File containing SI references").addButton((btn) => {
      this.siFileButton = btn;
      btn.onClick(() => {
        const visibleFiles = this.showAllFiles ? this.allFiles : this.allFiles.filter((f) => !f.includes("/"));
        const options = ["None", ...visibleFiles];
        new FileSuggestModal(this.app, options, (file) => {
          this.config.siFile = file === "None" ? null : file;
          this.updateFileSelectors();
        }).open();
      });
    });
    this.siFileContainer.style.display = this.config.includeSiRefs ? "block" : "none";
    new import_obsidian.Setting(siGrid).setClass("manuscript-setting-compact").setName("SI Formatting").setDesc("S-prefixed figures/tables").addToggle((toggle) => {
      this.isSiToggle = toggle;
      toggle.setValue(this.config.isSi);
      toggle.onChange((value) => {
        this.config.isSi = value;
      });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Restore Defaults").onClick(() => {
      this.restoreDefaults();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Build").setCta().onClick(() => {
      if (!this.config.sourceFile) {
        new import_obsidian.Notice("Please select a source file");
        return;
      }
      this.close();
      this.plugin.executeBuild(this.config);
    });
    this.updateFileSelectors();
  }
  restoreDefaults() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const mdFiles = this.allFiles;
    const settings = this.plugin.settings;
    this.showAllFiles = false;
    this.config.profile = settings.defaultProfile;
    this.config.font = settings.defaultFont;
    this.config.fontSize = settings.defaultFontSize;
    this.config.citationStyle = settings.defaultCitationStyle;
    this.config.lineSpacing = "";
    this.config.paragraphStyle = "";
    this.config.lineNumbers = null;
    this.config.pageNumbers = null;
    this.config.numberedHeadings = null;
    this.config.language = "";
    this.config.usePng = false;
    this.config.includeSiRefs = false;
    this.config.isSi = false;
    this.config.texMode = "";
    this.config.figureFormat = "png";
    this.config.figureBackground = "white";
    this.config.paperSize = "";
    this.config.margins = "";
    this.config.marginTop = "";
    this.config.marginBottom = "";
    this.config.marginLeft = "";
    this.config.marginRight = "";
    this.config.visualizeCaptions = settings.defaultVisualizeCaptions;
    this.config.captionStyle = settings.defaultCaptionStyle;
    this.config.digitalGarden = false;
    const maintext = mdFiles.find((f) => f.includes("maintext"));
    this.config.sourceFile = maintext || mdFiles[0] || "";
    const frontmatter = mdFiles.find((f) => f.includes("frontmatter"));
    this.config.frontmatterFile = frontmatter || null;
    const siFile = mdFiles.find((f) => f.includes("supp"));
    this.config.siFile = siFile || mdFiles[0] || null;
    let currentFormat = this.config.profile.startsWith("docx") ? "docx" : "pdf";
    if (currentFormat === "pdf" && this.config.texMode) {
      currentFormat = "latex";
    }
    const profileFormat = currentFormat === "latex" ? "pdf" : currentFormat;
    (_a = this.formatDropdown) == null ? void 0 : _a.setValue(currentFormat);
    this.populateProfiles(this.profileDropdown, profileFormat);
    (_b = this.profileDropdown) == null ? void 0 : _b.setValue(this.config.profile);
    (_c = this.fontDropdown) == null ? void 0 : _c.setValue(this.config.font);
    (_d = this.fontSizeDropdown) == null ? void 0 : _d.setValue(this.config.fontSize);
    (_e = this.lineSpacingDropdown) == null ? void 0 : _e.setValue(this.config.lineSpacing);
    (_f = this.paragraphStyleDropdown) == null ? void 0 : _f.setValue(this.config.paragraphStyle);
    (_g = this.lineNumbersDropdown) == null ? void 0 : _g.setValue("default");
    (_h = this.pageNumbersDropdown) == null ? void 0 : _h.setValue("default");
    (_i = this.numberedHeadingsDropdown) == null ? void 0 : _i.setValue("default");
    (_j = this.languageDropdown) == null ? void 0 : _j.setValue(this.config.language);
    (_k = this.paperSizeDropdown) == null ? void 0 : _k.setValue(this.config.paperSize);
    (_l = this.marginsDropdown) == null ? void 0 : _l.setValue(this.config.margins);
    (_m = this.marginTopInput) == null ? void 0 : _m.setValue(this.config.marginTop);
    (_n = this.marginBottomInput) == null ? void 0 : _n.setValue(this.config.marginBottom);
    (_o = this.marginLeftInput) == null ? void 0 : _o.setValue(this.config.marginLeft);
    (_p = this.marginRightInput) == null ? void 0 : _p.setValue(this.config.marginRight);
    (_q = this.citationDropdown) == null ? void 0 : _q.setValue(this.config.citationStyle);
    (_r = this.pngToggle) == null ? void 0 : _r.setValue(this.config.usePng);
    (_s = this.siRefsToggle) == null ? void 0 : _s.setValue(this.config.includeSiRefs);
    (_t = this.isSiToggle) == null ? void 0 : _t.setValue(this.config.isSi);
    (_u = this.figureFormatDropdown) == null ? void 0 : _u.setValue(this.config.figureFormat);
    (_v = this.figureBackgroundDropdown) == null ? void 0 : _v.setValue(this.config.figureBackground);
    (_w = this.visualizeCaptionsToggle) == null ? void 0 : _w.setValue(this.config.visualizeCaptions);
    (_x = this.captionStyleToggle) == null ? void 0 : _x.setValue(this.config.captionStyle === "html");
    (_y = this.digitalGardenToggle) == null ? void 0 : _y.setValue(this.config.digitalGarden);
    this.updateFormatOptions(currentFormat);
    this.siFileContainer.style.display = "none";
    if (this.figureBackgroundContainer) {
      this.figureBackgroundContainer.style.display = "block";
    }
    this.updateFileSelectors();
    new import_obsidian.Notice("Settings restored to defaults");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  createSectionHeader(container, title) {
    container.createEl("h3", { text: title, cls: "setting-section-header" });
  }
  populateProfiles(dropdown, format) {
    dropdown.selectEl.empty();
    const profiles = this.plugin.getProfiles();
    const categories = /* @__PURE__ */ new Map();
    profiles.filter((p) => p.format === format).forEach((profile) => {
      var _a;
      if (!categories.has(profile.category)) {
        categories.set(profile.category, []);
      }
      (_a = categories.get(profile.category)) == null ? void 0 : _a.push(profile);
    });
    categories.forEach((profiles2, category) => {
      const optgroup = dropdown.selectEl.createEl("optgroup", { attr: { label: category } });
      profiles2.forEach((profile) => {
        optgroup.createEl("option", {
          value: profile.id,
          text: profile.name
        });
      });
    });
  }
  updateProfilesForFormat(format) {
    this.populateProfiles(this.profileDropdown, format);
    const defaultProfile = format === "docx" ? "docx-manuscript" : "pdf-default";
    this.profileDropdown.setValue(defaultProfile);
    this.config.profile = defaultProfile;
  }
  updateFormatOptions(format) {
    this.pngContainer.style.display = format === "docx" ? "block" : "none";
    if (this.latexModeContainer) {
      this.latexModeContainer.style.display = format === "latex" ? "block" : "none";
    }
    if (this.flattenedMdContainer) {
      this.flattenedMdContainer.style.display = format === "md" ? "block" : "none";
    }
    if (this.profileDropdown) {
      const profileContainer = this.profileDropdown.selectEl.closest(".setting-item");
      if (profileContainer) {
        profileContainer.style.display = format === "md" ? "none" : "block";
      }
    }
    if (this.typographySection) {
      this.typographySection.style.display = format === "pdf" || format === "latex" ? "block" : "none";
    }
    if (this.citationsSection) {
      this.citationsSection.style.display = "block";
    }
  }
};
var BuildOutputModal = class extends import_obsidian.Modal {
  constructor(app, fileName) {
    super(app);
    this.fileName = fileName;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("manuscript-build-output-modal");
    const header = contentEl.createDiv({ cls: "output-header" });
    header.createEl("h2", { text: "Building Manuscript" });
    this.statusEl = header.createEl("span", { cls: "build-status building", text: "Building..." });
    contentEl.createEl("p", { text: `Source: ${this.fileName}`, cls: "output-file-info" });
    this.outputEl = contentEl.createEl("pre", { cls: "build-output" });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Copy Log").onClick(() => {
      navigator.clipboard.writeText(this.outputEl.innerText);
      new import_obsidian.Notice("Log copied to clipboard");
    });
    new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Close").onClick(() => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  appendOutput(text, isError = false) {
    const span = this.outputEl.createEl("span", {
      text,
      cls: isError ? "output-error" : "output-text"
    });
    this.outputEl.scrollTop = this.outputEl.scrollHeight;
  }
  setSuccess() {
    this.statusEl.setText("\u2713 Complete");
    this.statusEl.removeClass("building");
    this.statusEl.addClass("success");
  }
  setError() {
    this.statusEl.setText("\u2717 Failed");
    this.statusEl.removeClass("building");
    this.statusEl.addClass("error");
  }
};
var ManuscriptBuildSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Manuscript Build Settings" });
    containerEl.createEl("h3", { text: "System", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Python Path").setDesc("Path to Python executable (python3, python, or full path)").addText(
      (text) => text.setPlaceholder("python3").setValue(this.plugin.settings.pythonPath).onChange(async (value) => {
        this.plugin.settings.pythonPath = value || "python3";
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Build Script Path").setDesc("Path to build.py (leave empty to use internal script)").addText(
      (text) => text.setPlaceholder("Internal Default").setValue(this.plugin.settings.buildScriptPath).onChange(async (value) => {
        this.plugin.settings.buildScriptPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Bibliography File").setDesc("Path to references.json file relative to vault root").addText(
      (text) => text.setPlaceholder("references.json").setValue(this.plugin.settings.bibliographyPath).onChange(async (value) => {
        this.plugin.settings.bibliographyPath = value || "references.json";
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Defaults", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Default Profile").setDesc("Default output profile for new builds").addDropdown((dropdown) => {
      this.plugin.getProfiles().forEach((profile) => {
        dropdown.addOption(profile.id, `${profile.name} (${profile.format.toUpperCase()})`);
      });
      dropdown.setValue(this.plugin.settings.defaultProfile);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultProfile = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default Font").setDesc("Default typeface for PDF builds").addDropdown((dropdown) => {
      dropdown.addOption("", "Profile Default");
      Object.entries(FONT_PRESETS).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.plugin.settings.defaultFont || "");
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultFont = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default Font Size").setDesc("Default font size for PDF builds (Note: >12pt requires compatible profiles like Notes or Thesis)").addDropdown((dropdown) => {
      FONT_SIZES.forEach((size) => {
        dropdown.addOption(size, size);
      });
      dropdown.setValue(this.plugin.settings.defaultFontSize);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultFontSize = value;
        await this.plugin.saveSettings();
      });
    });
    const citationStyles = this.plugin.getCitationStyles();
    new import_obsidian.Setting(containerEl).setName("Default Citation Style").setDesc("Default bibliography format").addDropdown((dropdown) => {
      Object.entries(citationStyles).forEach(([key, name]) => {
        dropdown.addOption(key, name);
      });
      dropdown.setValue(this.plugin.settings.defaultCitationStyle);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultCitationStyle = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default Visualize Captions").setDesc("Default setting for 'Visualize Captions' in Flattened Markdown builds").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.defaultVisualizeCaptions).onChange(async (value) => {
        this.plugin.settings.defaultVisualizeCaptions = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Default Caption Style").setDesc("Default setting for 'HTML Figures & Captions' in Flattened Markdown builds").addDropdown((dropdown) => {
      dropdown.addOption("plain", "Plain Markdown");
      dropdown.addOption("html", "HTML <figure>");
      dropdown.setValue(this.plugin.settings.defaultCaptionStyle);
      dropdown.onChange(async (value) => {
        this.plugin.settings.defaultCaptionStyle = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Add Citation Styles", cls: "setting-section-header" });
    const styleInfoEl = containerEl.createDiv({ cls: "setting-item-description citation-style-info" });
    styleInfoEl.innerHTML = `
			<p>To add a new citation style:</p>
			<ol>
				<li>Find your style at <strong>zotero.org/styles</strong></li>
				<li>Download the <code>.csl</code> file</li>
				<li>Place it in the <code>resources/citation_styles</code> folder inside the plugin directory.</li>
				<li>Reopen this dialog to see the new style</li>
			</ol>
		`;
    new import_obsidian.Setting(containerEl).setName("Browse Zotero Styles").setDesc("Open the Zotero Style Repository to find citation styles").addButton(
      (button) => button.setButtonText("Open Zotero Styles").onClick(() => {
        window.open("https://www.zotero.org/styles", "_blank");
      })
    );
    new import_obsidian.Setting(containerEl).setName("Open Styles Folder").setDesc("Open the folder where citation style files are stored").addButton(
      (button) => button.setButtonText("Open Folder").onClick(() => {
        this.plugin.openCitationStylesFolder();
      })
    );
    containerEl.createEl("h3", { text: "Behavior", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Show Notifications").setDesc("Display build status notifications").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showNotifications).onChange(async (value) => {
        this.plugin.settings.showNotifications = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Auto-open Export Folder").setDesc("Open the export folder after successful builds").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoOpenExport).onChange(async (value) => {
        this.plugin.settings.autoOpenExport = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Actions", cls: "setting-section-header" });
    new import_obsidian.Setting(containerEl).setName("Open Export Folder").setDesc("Open the folder containing built documents").addButton(
      (button) => button.setButtonText("Open").onClick(() => {
        this.plugin.openExportFolder();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Install CSS Snippets").setDesc("Copy figure/table callout styles to Obsidian snippets").addButton(
      (button) => button.setButtonText("Install").onClick(() => {
        this.plugin.installCssSnippets();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Install Fonts").setDesc("Copy installation command to clipboard").addButton(
      (button) => button.setButtonText("Copy Command").onClick(() => {
        this.plugin.installFonts();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test Python").setDesc("Verify Python is accessible").addButton(
      (button) => button.setButtonText("Test").onClick(() => {
        this.testPython();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Copy Build Command").setDesc("Copy the command to run build.py manually").addButton(
      (button) => button.setButtonText("Copy Command").onClick(() => {
        this.plugin.getBuildCommand();
      })
    );
  }
  testPython() {
    var _a, _b;
    const { spawn: spawn2 } = require("child_process");
    const process2 = spawn2(this.plugin.settings.pythonPath, ["--version"]);
    let output = "";
    (_a = process2.stdout) == null ? void 0 : _a.on("data", (data) => {
      output += data.toString();
    });
    (_b = process2.stderr) == null ? void 0 : _b.on("data", (data) => {
      output += data.toString();
    });
    process2.on("close", (code) => {
      if (code === 0) {
        new import_obsidian.Notice(`\u2713 Python found: ${output.trim()}`);
      } else {
        new import_obsidian.Notice(`\u2717 Python not found at: ${this.plugin.settings.pythonPath}`);
      }
    });
    process2.on("error", () => {
      new import_obsidian.Notice(`\u2717 Python not found at: ${this.plugin.settings.pythonPath}`);
    });
  }
};
